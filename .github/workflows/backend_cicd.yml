name: Backend CI/CD

on:
  push:
    branches:
      - "**"
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (e.g., v1.2.3)"
        required: true

env:
  PYTHON_VERSION: "3.12"
  WORKDIR: ./packages/backend

jobs:
  verify:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      - uses: actions/checkout@v4

      - name: setup-python-poetry-deps
        uses: ./.github/actions/setup-python-poetry
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          working-directory: ${{ env.WORKDIR }}
          with-groups: "dev,test"

      - name: Lint
        run: poetry run ruff check .

      - name: Type check
        run: poetry run mypy .

      # Optional: upload venv as artifact for immediate reuse (same run)
      # - name: Upload venv artifact
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: backend-venv
      #     path: ${{ env.WORKDIR }}/.venv
      #     if-no-files-found: ignore
      #     retention-days: 1

  test:
    runs-on: ubuntu-latest
    needs: verify
    defaults:
      run:
        working-directory: ${{ env.WORKDIR }}
    steps:
      # Optional: download venv artifact if you used the above upload
      # - name: Download venv artifact
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: backend-venv
      #     path: ${{ env.WORKDIR }}/.venv
      - uses: actions/checkout@v4

      - name: Setup (Python + Poetry + deps)
        uses: ./.github/actions/setup-python-poetry
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          working-directory: ${{ env.WORKDIR }}
          with-groups: "dev,test"

      # - name: Test
      #   run: poetry run pytest -q

  build:
    if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    needs: [verify, test]
    steps:
      - uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CR_PAT }}

      - name: Extract version from tag
        id: get_version
        run: echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: packages/backend
          push: true
          tags: ghcr.io/${{ vars.USERNAME }}/${{ vars.REPOSITORY_NAME }}/${{ vars.IMAGE_BACKEND }}:${{ env.VERSION }}

  release:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: [verify, test]
    steps:
      - uses: actions/checkout@v4

      - name: Checkout code (main)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Validate branch is main
        run: |
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "Release can only be triggered on main branch. Current: $CURRENT_BRANCH"
            exit 1
          fi

      - name: Validate input tag exists and is on main
        run: |
          TAG="${{ github.event.inputs.tag }}"
          if [ -z "$TAG" ]; then
            echo "No tag provided."
            exit 1
          fi
          if ! git rev-parse -q --verify "refs/tags/$TAG" >/dev/null; then
            echo "Tag '$TAG' does not exist."
            exit 1
          fi
          TAG_COMMIT=$(git rev-list -n 1 "refs/tags/$TAG")
          if ! git merge-base --is-ancestor "$TAG_COMMIT" origin/main; then
            echo "Tag '$TAG' is not reachable from main."
            exit 1
          fi

      # - name: Connect to Raspberry Pi and update application
      #   uses: apple-oss-distributions/raspberry-pi-connect-action@v1
      #   with:
      #     host: ${{ secrets.RPI_HOST }}
      #     username: ${{ secrets.RPI_USERNAME }}
      #     password: ${{ secrets.RPI_PASSWORD }}
      #     script: |
      #       set -euo pipefail
      #       cd ${{ secrets.APP_PATH }}
      #       export VERSION=${{ github.event.inputs.tag }}
      #       docker compose -f docker-compose.prod.yml pull
      #       docker compose -f docker-compose.prod.yml up -d

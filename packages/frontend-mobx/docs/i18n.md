# Internationalization (i18n)

This document explains how i18n is implemented in the Freedom Label frontend, and how to safely add or modify translations.

## Overview

We use `i18next` with `react-i18next` and bundle static JSON resource files per locale. Current supported languages:

- English (`en` – default / fallback)
- Italian (`it`)

Initialization happens once at app startup and in the test setup (`vitest.setup.ts`) so all tests render with the default English texts unless they explicitly change language.

## File & Module Locations

| Concern                    | Path                                     |
| -------------------------- | ---------------------------------------- |
| i18n bootstrap & utilities | `src/i18n.ts`                            |
| Locale resources           | `src/assets/locales/{en,it}/common.json` |
| Default language constant  | `src/i18n.ts (DEFAULT_LANG)`             |
| Supported langs list       | `src/i18n.ts (SUPPORTED_LANGS)`          |
| Language persistence key   | `freedom-label:lang` (localStorage)      |

## Key Conventions

We follow these conventions:

1. Namespace: Single namespace `common` for MVP scope. Add more only when size/concern separation provides clarity.
2. Casing: camelCase keys (e.g. `createLabel`, `changeLanguage`, `languageSelector`).
3. Semantics: Keys express semantic purpose, not presentation or literal English (avoid `create_label_button_text`).
4. Alphabetical Ordering: Keys inside each JSON file are sorted A→Z to reduce merge conflicts and ease scanning.
5. Reuse: Prefer reusing an existing key instead of adding a duplicate with slightly different wording.
6. Singular vs Plural: Use distinct keys if pluralization requires different grammar (future: consider `i18next` plural rules when needed).

## Adding a New Translation Key

1. Pick a semantic camelCase name.
2. Insert it alphabetically in `en/common.json` with the English string.
3. Insert the same key alphabetically in `it/common.json` with the Italian translation (or temporarily copy English if untranslated, but add a `// TODO` comment in PR description; do not leave missing keys silently).
4. Use it in components via the `t('yourKey')` helper from `useTranslation('common')`.
5. If user-facing, add/update tests to query by accessible name (role + aria-label/visible text) rather than raw key; tests must remain language‑agnostic when feasible.
6. Run tests & lint to ensure no orphan / unused key issues (manual for now).

## Changing / Removing Keys

Renaming impacts all usages. Recommended flow:

1. Add the new key with the new semantic name.
2. Update components to use the new key.
3. Run tests, ensure they pass.
4. Remove the old key from all locale files in the same commit (or a follow-up if large).
5. Avoid bulk renames mixed with functional changes—keep diffs reviewable.

## Language Detection & Persistence

Detection order (`detectInitialLanguage`):

1. Stored user preference in `localStorage` (`freedom-label:lang`)
2. Navigator language prefix (`navigator.language.slice(0, 2)`) if supported
3. Default fallback (`en`)

When `changeLanguage(lng)` is called:

- `i18n.changeLanguage(lng)` executes (async but fire-and-forget for speed)
- `persistLanguage(lng)` stores preference
- UI re-renders via `useTranslation`

## Where Language Can Be Changed

The Header has a language menu button (globe icon) toggling a simple listbox of supported languages. Selecting an item calls `changeLanguage(lng)` and closes the menu while returning focus to the toggle button.

## Accessibility Notes

- Every translatable label used for an accessible name (e.g. aria-label, button text) must remain concise and descriptive.
- Role + name queries in tests (e.g. `screen.findByRole('button', { name: /change language|cambia lingua/i })`) validate both localization & accessibility.
- Live regions (e.g. feedback Snackbars) are polite and rely on translated message keys for announcement.

## Testing Strategy

Types of i18n tests present:

1. Default rendering: Ensures English strings appear on first render.
2. Interaction switch: Opens the language selector, chooses Italian, asserts Italian UI strings.
3. Persistence: Switch to Italian, unmount/remount, still Italian.
4. Programmatic change: Calls `changeLanguage('it')` directly, asserts UI updates.
5. Round-trip: Switch to Italian then back to English.

Guidelines:

- Prefer role/name queries; avoid brittle text-only queries when the element has a semantic role.
- For options that appear in different languages, use regex matching both localized forms if test itself triggers translation transition.
- When adding new i18n-reliant features, include one focused test—not a cascade of similar assertions.

## Adding Another Language

1. Add code `SUPPORTED_LANGS` entry in `src/i18n.ts` (e.g. `'fr'`).
2. Create `src/assets/locales/fr/common.json` (sorted, full set of keys).
3. Update Header language list mapping logic if any special-case label mapping is used (currently labelKey switch on `'en'` vs `'it'`; refactor to a lookup map when >2 languages).
4. Add a minimal test: programmatic switch to new language and assert one or two representative labels.
5. Update documentation & possibly README badges.

## Performance Considerations

- Static JSON resources are tree‑shaken/bundled; no runtime network fetch for locales.
- Single namespace avoids multiple network/IO lookups and simplifies test initialization.
- `returnEmptyString: false` ensures missing keys are more visible (falls back to key name rather than showing blank).

## Common Pitfalls & How to Avoid Them

| Pitfall                              | Avoidance                                                       |
| ------------------------------------ | --------------------------------------------------------------- |
| Hardcoding visible strings           | Always use `t('key')`; add key if missing.                      |
| Duplicate keys meaning same thing    | Reuse existing semantic key.                                    |
| Tests failing after key rename       | Add new key, update tests, then remove old key in same PR.      |
| Language-specific casing differences | Write regex queries case-insensitively in tests.                |
| Forgetting alphabetical order        | Re-run diff, reorder before commit.                             |
| Adding a key to only one locale      | CI/tests should catch missing translations—ensure both updated. |

## Example: Adding a New Action Label

1. Decide on key: `downloadReport`.
2. Edit `en/common.json` (alphabetically) adding: `"downloadReport": "Download report",`
3. Edit `it/common.json` adding: `"downloadReport": "Scarica report",`
4. In component: `const { t } = useTranslation('common'); <button>{t('downloadReport')}</button>`
5. Add test (if new UI element): `expect(screen.getByRole('button', { name: /download report|scarica report/i })).toBeInTheDocument();`

## Future Enhancements (Backlog Ideas)

- Pluralization & interpolation examples (once needed)
- Extract language selector to accessible component with keyboard roving
- Lint rule / script to enforce alphabetical key ordering + unused key detection
- Visual snapshot tests per locale (low priority until UI stabilizes)

## Maintainer Checklist for PRs Touching i18n

- [ ] Keys alphabetical in all modified locale files
- [ ] Semantic camelCase naming
- [ ] Both (all) locale files updated
- [ ] No stray hardcoded English in new UI
- [ ] Tests updated / added (at least one meaningful assertion)
- [ ] Docs (this file) updated if patterns change

---

If anything here becomes outdated as features evolve, please update this document in the same PR as the code changes.
